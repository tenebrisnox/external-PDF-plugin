/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin 
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExternalPDFPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultHeight: "600px",
  restrictDomains: false,
  allowedDomains: ["drive.google.com", "dropbox.com", "onedrive.live.com", "github.com"],
  showPDFPreview: true,
  enableQuickActions: true,
  maxFileSize: 50,
  // 50MB
  pdfJsWorkerUrl: "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js",
  defaultScale: 1.2,
  allowAbsolutePaths: false
  // Default to false for security
};
var ExternalPDFSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "External PDF Plugin" });
    const infoDiv = containerEl.createEl("div", { cls: "external-pdf-info" });
    const p1 = infoDiv.createEl("p");
    p1.createEl("strong", { text: "Embed external PDFs, local vault PDFs, and local absolute path PDFs (desktop only) directly in your notes with full viewer controls." });
    infoDiv.createEl("h3", { text: "\u{1F4D6} How to Use" });
    const p2 = infoDiv.createEl("p");
    p2.appendText("Add a code block with ");
    p2.createEl("code", { text: "external-pdf" });
    p2.appendText(" language and provide the source:");
    const p3 = infoDiv.createEl("p");
    p3.createEl("strong", { text: "For external PDFs (HTTPS URLs):" });
    const pre1 = infoDiv.createEl("pre");
    pre1.createEl("code", { text: `\`\`\`external-pdf
https://example.com/document.pdf
title: My Online Document
height: 500px
\`\`\`` });
    const p4 = infoDiv.createEl("p");
    p4.createEl("strong", { text: "For local PDFs in your vault (relative path from vault root):" });
    const pre2 = infoDiv.createEl("pre");
    pre2.createEl("code", { text: `\`\`\`external-pdf
Attachments/MyLocalDocument.pdf
title: Vault PDF
height: 400px
\`\`\`` });
    const p5 = infoDiv.createEl("p");
    p5.createEl("strong", { text: "For local PDFs via absolute path (Desktop Only, requires enabling below):" });
    const pre3 = infoDiv.createEl("pre");
    const absolutePathExample = import_obsidian.Platform.isWin ? "C:/Users/YourName/Documents/AbsoluteDoc.pdf" : "/Users/YourName/Documents/AbsoluteDoc.pdf";
    pre3.createEl("code", { text: `\`\`\`external-pdf
${absolutePathExample}
title: Absolute Path PDF
\`\`\`` });
    infoDiv.createEl("h3", { text: "\u{1F527} Supported Options" });
    const ul1 = infoDiv.createEl("ul");
    const li1 = ul1.createEl("li");
    li1.createEl("strong", { text: "title:" });
    li1.appendText(" Display name for the PDF");
    const li2 = ul1.createEl("li");
    li2.createEl("strong", { text: "height:" });
    li2.appendText(" Viewer height (e.g., 600px, 80vh, 400)");
    infoDiv.createEl("h3", { text: "\u{1F310} Supported Sources" });
    const ul2 = infoDiv.createEl("ul");
    let li = ul2.createEl("li");
    li.appendText("Local PDF files from your Obsidian vault (e.g., ");
    li.createEl("code", { text: "Attachments/MyReport.pdf" });
    li.appendText(")");
    li = ul2.createEl("li");
    const absolutePathExample2 = import_obsidian.Platform.isWin ? "D:\\\\Docs\\\\report.pdf" : "/mnt/data/report.pdf";
    li.appendText("Local PDF files via absolute path (e.g., ");
    li.createEl("code", { text: absolutePathExample2 });
    li.appendText(") - ");
    li.createEl("strong", { text: "Desktop Only, requires enabling in settings." });
    ul2.createEl("li", { text: "Google Drive (sharing links)" });
    ul2.createEl("li", { text: "Dropbox (sharing links)" });
    ul2.createEl("li", { text: "OneDrive (sharing links)" });
    ul2.createEl("li", { text: "GitHub (raw PDF files)" });
    ul2.createEl("li", { text: "Any direct HTTPS PDF URL" });
    infoDiv.createEl("h3", { text: "\u{1F4F1} Features" });
    const ul3 = infoDiv.createEl("ul");
    ul3.createEl("li", { text: "Mobile-optimized with touch gestures (for URLs and vault files)" });
    ul3.createEl("li", { text: "Keyboard navigation (arrows, space, +/- zoom)" });
    ul3.createEl("li", { text: "Page controls and zoom options" });
    ul3.createEl("li", { text: "Fit-to-width mode" });
    ul3.createEl("li", { text: "Pinch-to-zoom on mobile" });
    ul3.createEl("li", { text: "Swipe gestures for page navigation" });
    containerEl.createEl("h3", { text: "Settings" });
    new import_obsidian.Setting(containerEl).setName("Default height").setDesc("Default height for PDF viewers (e.g., 600px, 70vh)").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.defaultHeight).setValue(this.plugin.settings.defaultHeight).onChange(async (value) => {
      this.plugin.settings.defaultHeight = value || DEFAULT_SETTINGS.defaultHeight;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Allow absolute local file paths (Desktop Only)").setDesc("Enable embedding PDFs using absolute file paths (e.g., /path/to/file.pdf or C:\\path\\to\\file.pdf). Use with caution: granting access to arbitrary file paths can have security implications if untrusted content is processed. This feature only works on Obsidian desktop.").addToggle((toggle) => toggle.setValue(this.plugin.settings.allowAbsolutePaths).onChange(async (value) => {
      this.plugin.settings.allowAbsolutePaths = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.allowAbsolutePaths && !import_obsidian.Platform.isDesktop) {
      containerEl.createEl("p", { text: "Warning: Absolute paths are only functional on the Obsidian desktop application.", cls: "external-pdf-warning" });
    }
    new import_obsidian.Setting(containerEl).setName("Restrict domains (for external URLs)").setDesc("If enabled, only allow PDFs from specified external domains. This does not apply to local vault files or absolute path files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.restrictDomains).onChange(async (value) => {
      this.plugin.settings.restrictDomains = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.restrictDomains) {
      new import_obsidian.Setting(containerEl).setName("Allowed external domains").setDesc("Comma-separated list of allowed external domains (e.g., drive.google.com, dropbox.com).").addTextArea((text) => text.setPlaceholder(DEFAULT_SETTINGS.allowedDomains.join(", ")).setValue(this.plugin.settings.allowedDomains.join(", ")).onChange(async (value) => {
        this.plugin.settings.allowedDomains = value.split(",").map((domain) => domain.trim().toLowerCase()).filter((domain) => domain.length > 0);
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Maximum file size (MB)").setDesc("Maximum allowed PDF file size for all sources (local vault, absolute path, external URL).").addSlider((slider) => slider.setLimits(1, 200, 5).setValue(this.plugin.settings.maxFileSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxFileSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default zoom scale").setDesc("Default zoom level for PDFs (1.0 = 100%). Applies when not on mobile or fit-to-width.").addSlider((slider) => slider.setLimits(0.5, 3, 0.1).setValue(this.plugin.settings.defaultScale).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.defaultScale = value;
      await this.plugin.saveSettings();
    }));
  }
};
var ExternalPDFPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.pdfJsLoaded = false;
    this.loadingPromise = null;
    this.nodeFs = null;
    this.nodePath = null;
  }
  async onload() {
    await this.loadSettings();
    if (import_obsidian.Platform.isDesktop && typeof require !== "undefined") {
      try {
        this.nodeFs = require("fs");
        this.nodePath = require("path");
      } catch (e) {
        console.warn("External PDF Plugin: Could not load Node.js 'fs' or 'path' module. Absolute path functionality will be limited.", e);
      }
    }
    this.addSettingTab(new ExternalPDFSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("external-pdf", (source, el, ctx) => {
      this.renderExternalPDF(source, el, ctx);
    });
    console.log("External PDF Plugin loaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadPDFJS() {
    if (this.pdfJsLoaded) return this.loadingPromise || Promise.resolve();
    if (this.loadingPromise) return this.loadingPromise;
    this.loadingPromise = new Promise((resolve, reject) => {
      const script = document.createElement("script");
      const pdfJsBaseUrl = this.settings.pdfJsWorkerUrl.substring(0, this.settings.pdfJsWorkerUrl.lastIndexOf("/") + 1);
      script.src = pdfJsBaseUrl + "pdf.min.js";
      script.onload = () => {
        if (window.pdfjsLib) {
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = this.settings.pdfJsWorkerUrl;
          this.pdfJsLoaded = true;
          resolve();
        } else {
          this.pdfJsLoaded = false;
          reject(new Error("PDF.js library failed to load onto window.pdfjsLib."));
        }
      };
      script.onerror = (err) => {
        this.pdfJsLoaded = false;
        console.error("Failed to load PDF.js script:", err);
        reject(new Error(`Failed to load PDF.js script from ${script.src}`));
      };
      document.head.appendChild(script);
    });
    try {
      await this.loadingPromise;
    } catch (e) {
      this.loadingPromise = null;
      throw e;
    }
    return this.loadingPromise;
  }
  isMobileDevice() {
    return import_obsidian.Platform.isMobile;
  }
  isValidURL(urlString) {
    try {
      const url = new URL(urlString);
      return url.protocol === "http:" || url.protocol === "https:";
    } catch (e) {
      return false;
    }
  }
  isPotentiallyAbsolutePath(pathString) {
    if (!pathString) return false;
    if (import_obsidian.Platform.isWin) {
      return /^[a-zA-Z]:[\\\/]/.test(pathString) || pathString.startsWith("\\\\");
    } else {
      return pathString.startsWith("/");
    }
  }
  isDomainAllowed(urlString) {
    if (!this.isValidURL(urlString)) return false;
    const url = new URL(urlString);
    if (url.protocol !== "https:") return false;
    if (!this.settings.restrictDomains) return true;
    try {
      const hostname = url.hostname.toLowerCase();
      return this.settings.allowedDomains.some(
        (domain) => hostname === domain || hostname.endsWith("." + domain)
      );
    } catch (e) {
      return false;
    }
  }
  async fetchExternalPDFData(url) {
    const directUrl = this.getDirectDownloadURL(url);
    const response = await (0, import_obsidian.requestUrl)({ url: directUrl, method: "GET", headers: { "Accept": "application/pdf,*/*" } });
    if (!response.arrayBuffer) throw new Error("No PDF data received from URL");
    this.checkFileSize(response.arrayBuffer.byteLength, `External PDF from ${url}`);
    return response.arrayBuffer;
  }
  async fetchLocalPDFData(file) {
    const fileData = await this.app.vault.readBinary(file);
    this.checkFileSize(fileData.byteLength, `Local vault PDF ${file.path}`);
    return fileData;
  }
  async fetchAbsoluteLocalPDFData(filePath) {
    if (!import_obsidian.Platform.isDesktop || !this.nodeFs || !this.nodePath) {
      throw new Error("Absolute path access is only supported on Obsidian desktop and requires Node.js 'fs' and 'path' modules.");
    }
    try {
      const normalizedPath = this.nodePath.normalize(filePath);
      if (!this.nodeFs.existsSync(normalizedPath)) {
        throw new Error(`File not found at absolute path: ${normalizedPath}`);
      }
      const stats = this.nodeFs.statSync(normalizedPath);
      if (!stats.isFile()) {
        throw new Error(`Path is not a file: ${normalizedPath}`);
      }
      const fileDataBuffer = this.nodeFs.readFileSync(normalizedPath);
      const arrayBuffer = fileDataBuffer.buffer.slice(fileDataBuffer.byteOffset, fileDataBuffer.byteOffset + fileDataBuffer.byteLength);
      this.checkFileSize(arrayBuffer.byteLength, `Absolute path PDF ${normalizedPath}`);
      return arrayBuffer;
    } catch (error) {
      console.error(`Error reading absolute local PDF file ${filePath}:`, error);
      throw new Error(`Reading file ${filePath}: ${error.message || "Unknown fs error"}`);
    }
  }
  checkFileSize(byteLength, sourceDescription) {
    const sizeInMB = byteLength / (1024 * 1024);
    if (sizeInMB > this.settings.maxFileSize) {
      throw new Error(`PDF file too large: ${sizeInMB.toFixed(1)}MB (max: ${this.settings.maxFileSize}MB). Source: ${sourceDescription}`);
    }
  }
  getDirectDownloadURL(url) {
    try {
      const urlObj = new URL(url);
      const hostname = urlObj.hostname.toLowerCase();
      if (hostname.includes("drive.google.com")) {
        const fileIdMatch = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
        if (fileIdMatch) return `https://drive.google.com/uc?export=download&id=${fileIdMatch[1]}`;
      }
      if (hostname.includes("dropbox.com")) {
        const newUrl = new URL(url);
        newUrl.hostname = "dl.dropboxusercontent.com";
        newUrl.searchParams.set("dl", "1");
        return newUrl.toString();
      }
      if (hostname.includes("onedrive.live.com") || hostname.includes("1drv.ms")) {
        const newUrl = new URL(url);
        if (url.includes("/embed")) newUrl.pathname = newUrl.pathname.replace("/embed", "/download");
        newUrl.searchParams.set("download", "1");
        return newUrl.toString();
      }
    } catch (e) {
      console.warn("Could not parse URL for direct download conversion:", url, e);
    }
    return url;
  }
  parseOptions(lines) {
    const options = {};
    lines.slice(1).forEach((line) => {
      const trimmedLine = line.trim();
      const colonIndex = trimmedLine.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmedLine.substring(0, colonIndex).trim().toLowerCase();
        const value = trimmedLine.substring(colonIndex + 1).trim();
        options[key] = value;
      }
    });
    return options;
  }
  parseHeight(heightOption) {
    if (!heightOption) return this.settings.defaultHeight;
    if (/^\d+$/.test(heightOption)) return heightOption + "px";
    if (/^\d+(\.\d+)?(px|vh|vw|em|rem|%)$/i.test(heightOption)) return heightOption;
    return this.settings.defaultHeight;
  }
  createErrorElement(el, message) {
    el.empty();
    el.createEl("div", { text: message, cls: "external-pdf-error" });
  }
  createLoadingElement(el) {
    el.empty();
    const loadingContainer = el.createEl("div", { cls: "external-pdf-loading" });
    loadingContainer.createEl("div", { cls: "external-pdf-spinner" });
    loadingContainer.createEl("div", { text: "Loading PDF...", cls: "external-pdf-loading-text" });
    return loadingContainer;
  }
  async createPDFJSViewer(container, pdfData, options) {
    try {
      const pdf = await window.pdfjsLib.getDocument({ data: pdfData }).promise;
      const viewerContainer = container.createEl("div", { cls: "external-pdf-viewer" });
      const controls = viewerContainer.createEl("div", { cls: "external-pdf-controls" });
      const pageControls = controls.createEl("div", { cls: "external-pdf-page-controls" });
      const prevBtn = pageControls.createEl("button", { text: "\u2039", title: "Previous Page (ArrowLeft, PageUp)", cls: "external-pdf-nav-btn external-pdf-prev-btn" });
      const pageDisplay = pageControls.createEl("span", { cls: "external-pdf-page-display" });
      const nextBtn = pageControls.createEl("button", { text: "\u203A", title: "Next Page (ArrowRight, PageDown, Space)", cls: "external-pdf-nav-btn external-pdf-next-btn" });
      const zoomControls = controls.createEl("div", { cls: "external-pdf-zoom-controls" });
      const zoomOutBtn = zoomControls.createEl("button", { text: "\u2212", title: "Zoom Out (-)", cls: "external-pdf-zoom-btn" });
      const zoomDisplay = zoomControls.createEl("span", { cls: "external-pdf-zoom-display" });
      const zoomInBtn = zoomControls.createEl("button", { text: "+", title: "Zoom In (+, =)", cls: "external-pdf-zoom-btn" });
      const fitWidthBtn = zoomControls.createEl("button", { text: "Fit", title: "Fit to Width (0)", cls: "external-pdf-fit-btn" });
      const canvasContainer = viewerContainer.createEl("div", { cls: "external-pdf-canvas-container" });
      const heightValue = this.parseHeight(options.height);
      canvasContainer.style.setProperty("--pdf-viewer-max-height", heightValue);
      const canvas = canvasContainer.createEl("canvas", { cls: "external-pdf-canvas" });
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Failed to get canvas context");
      let currentPage = 1;
      let scale = this.isMobileDevice() ? 1 : this.settings.defaultScale;
      const minScale = 0.25;
      const maxScale = 5;
      let fitToWidth = false;
      const calculateFitToWidthScale = async (pageNum) => {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 1 });
        const containerWidth = canvasContainer.clientWidth > 0 ? canvasContainer.clientWidth - (this.isMobileDevice() ? 16 : 32) : 600 - 32;
        return Math.max(minScale, Math.min(maxScale, containerWidth / viewport.width));
      };
      const updatePageDisplay = () => {
        pageDisplay.textContent = `${currentPage} / ${pdf.numPages}`;
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= pdf.numPages;
      };
      const updateZoomDisplay = () => {
        const displayScale = fitToWidth ? "Fit" : `${Math.round(scale * 100)}%`;
        zoomDisplay.textContent = displayScale;
        zoomOutBtn.disabled = !fitToWidth && scale <= minScale;
        zoomInBtn.disabled = !fitToWidth && scale >= maxScale;
        fitWidthBtn.classList.toggle("active", fitToWidth);
      };
      const renderPage = async (pageNum) => {
        try {
          const page = await pdf.getPage(pageNum);
          let renderScale = scale;
          if (fitToWidth) {
            renderScale = await calculateFitToWidthScale(pageNum);
            if (scale !== renderScale) scale = renderScale;
          }
          const viewport = page.getViewport({ scale: renderScale });
          const outputScale = window.devicePixelRatio || 1;
          canvas.width = Math.floor(viewport.width * outputScale);
          canvas.height = Math.floor(viewport.height * outputScale);
          ctx.save();
          ctx.scale(outputScale, outputScale);
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, viewport.width, viewport.height);
          await page.render({ canvasContext: ctx, viewport }).promise;
          ctx.restore();
        } catch (renderError) {
          console.error(`Error rendering page ${pageNum}:`, renderError);
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "red";
          ctx.font = "16px sans-serif";
          ctx.fillText(`Error rendering page: ${renderError.message}`, 10, 30);
          ctx.restore();
        }
      };
      prevBtn.addEventListener("click", async () => {
        if (currentPage > 1) {
          currentPage--;
          updatePageDisplay();
          await renderPage(currentPage);
        }
      });
      nextBtn.addEventListener("click", async () => {
        if (currentPage < pdf.numPages) {
          currentPage++;
          updatePageDisplay();
          await renderPage(currentPage);
        }
      });
      zoomInBtn.addEventListener("click", async () => {
        if (fitToWidth) {
          fitToWidth = false;
          scale = await calculateFitToWidthScale(currentPage);
        }
        if (scale < maxScale) {
          scale = Math.min(scale * 1.25, maxScale);
          updateZoomDisplay();
          await renderPage(currentPage);
        }
      });
      zoomOutBtn.addEventListener("click", async () => {
        if (fitToWidth) {
          fitToWidth = false;
          scale = await calculateFitToWidthScale(currentPage);
        }
        if (scale > minScale) {
          scale = Math.max(scale / 1.25, minScale);
          updateZoomDisplay();
          await renderPage(currentPage);
        }
      });
      fitWidthBtn.addEventListener("click", async () => {
        fitToWidth = !fitToWidth;
        updateZoomDisplay();
        await renderPage(currentPage);
      });
      viewerContainer.tabIndex = 0;
      viewerContainer.addEventListener("keydown", async (e) => {
        if (e.target !== viewerContainer && !viewerContainer.contains(e.target)) return;
        let preventDefault = true;
        switch (e.key) {
          case "ArrowLeft":
          case "ArrowUp":
          case "PageUp":
            if (currentPage > 1) {
              currentPage--;
              updatePageDisplay();
              await renderPage(currentPage);
            }
            break;
          case "ArrowRight":
          case "ArrowDown":
          case "PageDown":
          case " ":
            if (currentPage < pdf.numPages) {
              currentPage++;
              updatePageDisplay();
              await renderPage(currentPage);
            }
            break;
          case "Home":
            if (currentPage !== 1) {
              currentPage = 1;
              updatePageDisplay();
              await renderPage(currentPage);
            }
            break;
          case "End":
            if (currentPage !== pdf.numPages) {
              currentPage = pdf.numPages;
              updatePageDisplay();
              await renderPage(currentPage);
            }
            break;
          case "+":
          case "=":
            if (fitToWidth) {
              fitToWidth = false;
              scale = await calculateFitToWidthScale(currentPage);
            }
            if (scale < maxScale) {
              scale = Math.min(scale * 1.25, maxScale);
              updateZoomDisplay();
              await renderPage(currentPage);
            }
            break;
          case "-":
            if (fitToWidth) {
              fitToWidth = false;
              scale = await calculateFitToWidthScale(currentPage);
            }
            if (scale > minScale) {
              scale = Math.max(scale / 1.25, minScale);
              updateZoomDisplay();
              await renderPage(currentPage);
            }
            break;
          case "0":
            fitToWidth = true;
            updateZoomDisplay();
            await renderPage(currentPage);
            break;
          default:
            preventDefault = false;
            break;
        }
        if (preventDefault) e.preventDefault();
      });
      if (this.isMobileDevice()) {
        let startX = 0, startY = 0, startDist = 0, currentScale = scale, isPinching = false;
        const getTouchDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        canvasContainer.addEventListener("touchstart", async (e) => {
          if (e.touches.length === 1) {
            startX = e.touches[0].pageX;
            startY = e.touches[0].pageY;
            isPinching = false;
          } else if (e.touches.length === 2) {
            e.preventDefault();
            startDist = getTouchDistance(e.touches);
            currentScale = fitToWidth ? await calculateFitToWidthScale(currentPage) : scale;
            isPinching = true;
            fitToWidth = false;
          }
        }, { passive: false });
        canvasContainer.addEventListener("touchmove", async (e) => {
          if (isPinching && e.touches.length === 2) {
            e.preventDefault();
            const dist = getTouchDistance(e.touches);
            if (startDist > 0) {
              const newScale = Math.max(minScale, Math.min(maxScale, currentScale * (dist / startDist)));
              if (Math.abs(newScale - scale) > 0.02) {
                scale = newScale;
                updateZoomDisplay();
                await renderPage(currentPage);
              }
            }
          }
        }, { passive: false });
        canvasContainer.addEventListener("touchend", async (e) => {
          if (e.changedTouches.length === 1 && e.touches.length === 0 && !isPinching) {
            const endX = e.changedTouches[0].pageX;
            const deltaX = endX - startX;
            if (Math.abs(deltaX) > 50) {
              if (deltaX > 0 && currentPage > 1) {
                currentPage--;
                updatePageDisplay();
                await renderPage(currentPage);
              } else if (deltaX < 0 && currentPage < pdf.numPages) {
                currentPage++;
                updatePageDisplay();
                await renderPage(currentPage);
              }
            }
          }
          if (isPinching && e.touches.length < 2) isPinching = false;
        });
      }
      updatePageDisplay();
      updateZoomDisplay();
      if (this.isMobileDevice()) {
        fitToWidth = true;
        updateZoomDisplay();
      }
      await renderPage(currentPage);
      if (this.isMobileDevice()) {
        const helpText = viewerContainer.createEl("div", { cls: "external-pdf-mobile-help" });
        helpText.textContent = 'Swipe for pages \u2022 Pinch to zoom \u2022 Tap "Fit"';
      }
    } catch (error) {
      console.error("Error in createPDFJSViewer:", error);
      this.createErrorElement(container, `Error displaying PDF: ${error.message || "Unknown PDF viewer error"}`);
    }
  }
  async renderExternalPDF(source, el, ctx) {
    var _a, _b;
    const lines = source.trim().split("\n");
    const sourceInput = (_a = lines[0]) == null ? void 0 : _a.trim();
    const options = this.parseOptions(lines);
    const isMobile = this.isMobileDevice();
    const container = el.createEl("div", {
      cls: "external-pdf-container" + (isMobile ? " external-pdf-mobile" : "")
    });
    if (options.title) {
      container.createEl("h3", { text: options.title, cls: "external-pdf-title" });
    }
    let pdfDataSource;
    if (!sourceInput) {
      pdfDataSource = { type: "error", message: "No PDF source (URL or local path) provided." };
    } else {
      const abstractFile = this.app.vault.getAbstractFileByPath(sourceInput);
      if (abstractFile instanceof import_obsidian.TFile && ((_b = abstractFile.extension) == null ? void 0 : _b.toLowerCase()) === "pdf") {
        pdfDataSource = { type: "vaultLocal", file: abstractFile };
      } else if (this.isValidURL(sourceInput)) {
        if (!this.isDomainAllowed(sourceInput)) {
          const errorMsgText = this.settings.restrictDomains ? `External domain not allowed. Allowed: ${this.settings.allowedDomains.join(", ")} (or disable domain restriction).` : "Only HTTPS URLs are allowed for external PDFs for security reasons.";
          pdfDataSource = { type: "error", message: errorMsgText };
        } else {
          pdfDataSource = { type: "url", url: sourceInput };
        }
      } else if (this.isPotentiallyAbsolutePath(sourceInput)) {
        if (!this.settings.allowAbsolutePaths) {
          pdfDataSource = { type: "error", message: "Absolute file paths are disabled. Enable them in plugin settings (Desktop Only)." };
        } else if (!import_obsidian.Platform.isDesktop) {
          pdfDataSource = { type: "error", message: "Absolute file paths are only supported on Obsidian desktop." };
        } else {
          pdfDataSource = { type: "absoluteLocal", path: sourceInput };
        }
      } else {
        pdfDataSource = { type: "error", message: `Invalid source: "${sourceInput}". Not a valid URL, vault file path, or recognizable absolute file path.` };
      }
    }
    if (pdfDataSource.type === "error") {
      this.createErrorElement(container, pdfDataSource.message);
      return;
    }
    const loadingEl = this.createLoadingElement(container);
    try {
      await this.loadPDFJS();
      let pdfData;
      switch (pdfDataSource.type) {
        case "vaultLocal":
          pdfData = await this.fetchLocalPDFData(pdfDataSource.file);
          break;
        case "url":
          pdfData = await this.fetchExternalPDFData(pdfDataSource.url);
          break;
        case "absoluteLocal":
          pdfData = await this.fetchAbsoluteLocalPDFData(pdfDataSource.path);
          break;
      }
      if (loadingEl.parentNode) loadingEl.remove();
      await this.createPDFJSViewer(container, pdfData, options);
    } catch (error) {
      console.error("Error loading or rendering PDF:", error);
      if (loadingEl.parentNode) loadingEl.remove();
      this.createErrorElement(container, `Failed to load PDF: ${error.message || "Unknown error"}`);
      if (pdfDataSource.type === "url") {
        const fallbackLink = container.createEl("p", { cls: "external-pdf-fallback" });
        fallbackLink.appendText("Try opening: ");
        fallbackLink.createEl("a", {
          text: pdfDataSource.url,
          href: this.getDirectDownloadURL(pdfDataSource.url),
          attr: { "target": "_blank", "rel": "noopener noreferrer" }
        });
      } else if (pdfDataSource.type === "vaultLocal") {
        const localFileNote = container.createEl("p", { cls: "external-pdf-fallback" });
        localFileNote.appendText("Problem with vault file: ");
        localFileNote.createEl("code", { text: pdfDataSource.file.path });
      } else if (pdfDataSource.type === "absoluteLocal") {
        const absFileNote = container.createEl("p", { cls: "external-pdf-fallback" });
        absFileNote.appendText("Problem with absolute path file: ");
        absFileNote.createEl("code", { text: pdfDataSource.path });
        absFileNote.appendText(".");
      }
    }
  }
  onunload() {
    this.pdfJsLoaded = false;
    this.loadingPromise = null;
    this.nodeFs = null;
    this.nodePath = null;
    console.log("External PDF Plugin unloaded");
  }
};
